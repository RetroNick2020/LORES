#include <stdio.h>
#include <stdlib.h>
#include <dos.h>
#include <conio.h>
#include "lores.h"
#include "tiler.h"

extern volatile unsigned int frameCount;
#if 0
/*
 * Map and tile data
 */
unsigned char testile[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                           0x9F, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xF9,
                           0x9F, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xF9,
                           0x9F, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xF9,
                           0x9F, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xF9,
                           0x9F, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xF9,
                           0x9F, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xF9,
                           0x9F, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xF9,
                           0x9F, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xF9,
                           0x9F, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xF9,
                           0x9F, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xF9,
                           0x9F, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xF9,
                           0x9F, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xF9,
                           0x9F, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xF9,
                           0x9F, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xF9,
                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
unsigned char testile1[] = {0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                           0x22, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x22,
                           0x22, 0x9F, 0x99, 0x99, 0x99, 0x99, 0xF9, 0x22,
                           0x22, 0x9F, 0x99, 0x99, 0x99, 0x99, 0xF9, 0x22,
                           0x22, 0x9F, 0x99, 0x99, 0x99, 0x99, 0xF9, 0x22,
                           0x22, 0x9F, 0x99, 0x99, 0x99, 0x99, 0xF9, 0x22,
                           0x22, 0x9F, 0x99, 0x99, 0x99, 0x99, 0xF9, 0x22,
                           0x22, 0x9F, 0x99, 0x99, 0x99, 0x99, 0xF9, 0x22,
                           0x22, 0x9F, 0x99, 0x99, 0x99, 0x99, 0xF9, 0x22,
                           0x22, 0x9F, 0x99, 0x99, 0x99, 0x99, 0xF9, 0x22,
                           0x22, 0x9F, 0x99, 0x99, 0x99, 0x99, 0xF9, 0x22,
                           0x22, 0x9F, 0x99, 0x99, 0x99, 0x99, 0xF9, 0x22,
                           0x22, 0x9F, 0x99, 0x99, 0x99, 0x99, 0xF9, 0x22,
                           0x22, 0x9F, 0x99, 0x99, 0x99, 0x99, 0xF9, 0x22,
                           0x22, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x22,
                           0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22};
unsigned char testile2[] = {0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                           0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                           0x22, 0x22, 0xFF, 0xFF, 0xFF, 0xFF, 0x22, 0x22,
                           0x22, 0x22, 0x9F, 0x99, 0x99, 0xF9, 0x22, 0x22,
                           0x22, 0x22, 0x9F, 0x99, 0x99, 0xF9, 0x22, 0x22,
                           0x22, 0x22, 0x9F, 0x99, 0x99, 0xF9, 0x22, 0x22,
                           0x22, 0x22, 0x9F, 0x99, 0x99, 0xF9, 0x22, 0x22,
                           0x22, 0x22, 0x9F, 0x99, 0x99, 0xF9, 0x22, 0x22,
                           0x22, 0x22, 0x9F, 0x99, 0x99, 0xF9, 0x22, 0x22,
                           0x22, 0x22, 0x9F, 0x99, 0x99, 0xF9, 0x22, 0x22,
                           0x22, 0x22, 0x9F, 0x99, 0x99, 0xF9, 0x22, 0x22,
                           0x22, 0x22, 0x9F, 0x99, 0x99, 0xF9, 0x22, 0x22,
                           0x22, 0x22, 0x9F, 0x99, 0x99, 0xF9, 0x22, 0x22,
                           0x22, 0x22, 0xFF, 0xFF, 0xFF, 0xFF, 0x22, 0x22,
                           0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                           0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22};
unsigned char testile3[] = {0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                          0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                          0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                          0x22, 0x22, 0x22, 0xFF, 0xFF, 0x22, 0x22, 0x22,
                          0x22, 0x22, 0x22, 0x9F, 0xF9, 0x22, 0x22, 0x22,
                          0x22, 0x22, 0x22, 0x9F, 0xF9, 0x22, 0x22, 0x22,
                          0x22, 0x22, 0x22, 0x9F, 0xF9, 0x22, 0x22, 0x22,
                          0x22, 0x22, 0x22, 0x9F, 0xF9, 0x22, 0x22, 0x22,
                          0x22, 0x22, 0x22, 0x9F, 0xF9, 0x22, 0x22, 0x22,
                          0x22, 0x22, 0x22, 0x9F, 0xF9, 0x22, 0x22, 0x22,
                          0x22, 0x22, 0x22, 0x9F, 0xF9, 0x22, 0x22, 0x22,
                          0x22, 0x22, 0x22, 0x9F, 0xF9, 0x22, 0x22, 0x22,
                          0x22, 0x22, 0x22, 0xFF, 0xFF, 0x22, 0x22, 0x22,
                          0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                          0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                          0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22};

unsigned char far *tileAnimate[4] = {testile, testile1, testile2, testile3};
unsigned char grass[] = {  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                           0x22, 0x2A, 0x22, 0x22, 0x22, 0x22, 0x32, 0x22,
                           0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                           0x22, 0x22, 0x22, 0x32, 0x22, 0x22, 0x22, 0x22,
                           0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                           0x22, 0x22, 0x22, 0x22, 0xA2, 0x22, 0x22, 0xA2,
                           0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                           0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                           0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                           0x22, 0x22, 0x32, 0x22, 0x22, 0x22, 0x2A, 0x22,
                           0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                           0x22, 0x22, 0x22, 0x2A, 0x22, 0x22, 0x22, 0x22,
                           0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                           0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                           0x22, 0x2A, 0x22, 0x22, 0x23, 0x22, 0x22, 0x22,
                           0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22};
unsigned char tree[] = {   0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                           0x22, 0x22, 0xA2, 0xAA, 0x2A, 0x2A, 0x22, 0x22,
                           0x22, 0xA2, 0xAA, 0xAA, 0xAA, 0xAA, 0x2A, 0x22,
                           0x22, 0xA2, 0xAA, 0xAA, 0xAA, 0xAA, 0x2A, 0x22,
                           0x22, 0x22, 0x2A, 0xA2, 0x2A, 0xA2, 0x2A, 0x22,
                           0x22, 0xAA, 0x2A, 0xAA, 0xAA, 0xA2, 0xAA, 0x22,
                           0x22, 0xAA, 0xAA, 0xAA, 0xAA, 0x2A, 0xAA, 0x22,
                           0x22, 0xA2, 0xAA, 0xAA, 0xA2, 0x2A, 0xAA, 0x22,
                           0x22, 0xAA, 0xAA, 0xAA, 0xA2, 0x2A, 0x2A, 0x22,
                           0x22, 0xA2, 0x2A, 0x22, 0xAA, 0xA2, 0xAA, 0x22,
                           0x22, 0xAA, 0xAA, 0xAA, 0xAA, 0x2A, 0xAA, 0x22,
                           0x22, 0x22, 0xAA, 0xAA, 0xAA, 0x22, 0xAA, 0x22,
                           0x22, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x2A, 0x22,
                           0x22, 0xA2, 0xA2, 0xAA, 0xAA, 0xAA, 0x2A, 0x22,
                           0x22, 0x22, 0xA2, 0xAA, 0x22, 0xAA, 0x22, 0x22,
                           0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22};
unsigned char dirt[] = {   0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
                           0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x76,
                           0x66, 0x60, 0x66, 0x66, 0x66, 0x60, 0x66, 0x66,
                           0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
                           0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
                           0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
                           0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
                           0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
                           0x66, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
                           0x66, 0x66, 0x66, 0x66, 0x06, 0x66, 0x76, 0x66,
                           0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
                           0x66, 0x06, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
                           0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
                           0x66, 0x66, 0x66, 0x06, 0x66, 0x66, 0x66, 0x66,
                           0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
                           0x66, 0x66, 0x66, 0x66, 0x66, 0x76, 0x66, 0x66};
unsigned char water[] = {  0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
                           0x11, 0x99, 0x11, 0x99, 0x11, 0x11, 0x11, 0x11,
                           0x11, 0x11, 0x99, 0x11, 0x99, 0x11, 0x11, 0x11,
                           0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
                           0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
                           0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
                           0x11, 0x11, 0x11, 0x11, 0x11, 0x99, 0x11, 0x99,
                           0x99, 0x11, 0x11, 0x11, 0x11, 0x11, 0x99, 0x11,
                           0x11, 0x11, 0x77, 0x11, 0x77, 0x11, 0x11, 0x11,
                           0x11, 0x11, 0x11, 0x77, 0x11, 0x77, 0x11, 0x11,
                           0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
                           0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
                           0x11, 0x11, 0x11, 0x99, 0x11, 0x99, 0x11, 0x11,
                           0x11, 0x11, 0x11, 0x11, 0x99, 0x11, 0x99, 0x11,
                           0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
                           0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11};
unsigned char far *tilemap[16][16];
/*
 * Build map from text representation
 *  . = grass
 *  * = tree
 *  # = dirt
 *  ~ = water
 */
unsigned char *map[] = {"................",
                        "..***...###.....",
                        ".****..##.###...",
                        "***~**.#....###.",
                        "**~~~*.#...~~~#~",
                        "~~~~~~~#~~~~..#.",
                        "*~~~**.#....###.",
                        ".****..#..###...",
                        ".****..#?##.....",
                        "..**..##........",
                        ".*...##..****...",
                        ".#####..*....*..",
                        "##.*...*.#..#.*.",
                        "#......*......*.",
                        "##.*....*.##.*..",
                        ".###.....****..."};
void buildmap(void)
{
    int row, col;
    unsigned char far *tileptr;

    for (row = 0; row < 16; row++)
    {
        for (col = 0; col < 16; col++)
        {
            switch (map[row][col])
            {
                case '.':
                    tileptr = grass;
                    break;
                case '*':
                    tileptr = tree;
                    break;
                case '#':
                    tileptr = dirt;
                    break;
                case '~':
                    tileptr = water;
                    break;
                default:
                    tileptr = testile;
            }
            tilemap[row][col] = tileptr;
        }
    }
}
/*
 * 20X20 Sprite
 */
#define FACE_WIDTH      20
#define FACE_HEIGHT     20
#define FACEBUF_WIDTH   (FACE_WIDTH+4)
#define FACEBUF_HEIGHT  (FACE_HEIGHT+4)

unsigned char face[FACE_HEIGHT*FACE_WIDTH/2] = {
     0x88, 0x88, 0x88, 0xE8, 0xEE, 0xEE, 0x8E, 0x88, 0x88, 0x88,
     0x88, 0x88, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0x88, 0x88,
     0x88, 0xE8, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0x8E, 0x88,
     0x88, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0x88,
     0x88, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0x88,
     0xE8, 0xEE, 0xEE, 0xE1, 0xEE, 0xEE, 0x1E, 0xEE, 0xEE, 0x8E,
     0xE8, 0xEE, 0x1E, 0x11, 0xEE, 0xEE, 0x11, 0xE1, 0xEE, 0x8E,
     0xEE, 0xEE, 0xEE, 0xE1, 0xEE, 0xEE, 0x1E, 0xEE, 0xEE, 0xEE,
     0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
     0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
     0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
     0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
     0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
     0xE8, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0x8E,
     0xE8, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0x8E,
     0x88, 0xEE, 0x44, 0xEE, 0xEE, 0xEE, 0xEE, 0x44, 0xEE, 0x88,
     0x88, 0xEE, 0xEE, 0x44, 0x44, 0x44, 0x44, 0xEE, 0xEE, 0x88,
     0x88, 0xE8, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0x8E, 0x88,
     0x88, 0x88, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0x88, 0x88,
     0x88, 0x88, 0x88, 0xE8, 0xEE, 0xEE, 0x8E, 0x88, 0x88, 0x88};
unsigned char angry[FACE_HEIGHT*FACE_WIDTH/2] = {
     0x88, 0x88, 0x88, 0xC8, 0xCC, 0xCC, 0x8C, 0x88, 0x88, 0x88,
     0x88, 0x88, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x88, 0x88,
     0x88, 0xC8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8C, 0x88,
     0x88, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x88,
     0x88, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x88,
     0xC8, 0xCC, 0xC1, 0xCC, 0xCC, 0xCC, 0xCC, 0x1C, 0xCC, 0x8C,
     0xC8, 0xCC, 0x1C, 0x11, 0xCC, 0xCC, 0x11, 0xC1, 0xCC, 0x8C,
     0xCC, 0xCC, 0xCC, 0xC1, 0xCC, 0xCC, 0x1C, 0xCC, 0xCC, 0xCC,
     0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
     0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
     0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
     0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
     0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
     0xC8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8C,
     0xC8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8C,
     0x88, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x88,
     0x88, 0xCC, 0xCC, 0xCC, 0x44, 0x44, 0xCC, 0xCC, 0xCC, 0x88,
     0x88, 0xC8, 0xCC, 0x44, 0xCC, 0xCC, 0x44, 0xCC, 0x8C, 0x88,
     0x88, 0x88, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x88, 0x88,
     0x88, 0x88, 0x88, 0xC8, 0xCC, 0xCC, 0x8C, 0x88, 0x88, 0x88};
#endif
#define WALL_TOP        0x01
#define WALL_BOTTOM     0x02
#define WALL_LEFT       0x04
#define WALL_RIGHT      0x08
#define BORDER_TOP      0
#define BORDER_BOTTOM   20
#define BORDER_LEFT     0
#define BORDER_RIGHT    20
unsigned char maze[BORDER_BOTTOM][BORDER_RIGHT];
unsigned char Enter, Exit, xDeadEnd, yDeadEnd;
#define FALSE           0
#define TRUE            (!FALSE)
#define DIR_ANY         0x00
#define DIR_UP          0x01
#define DIR_DOWN        0x02
#define DIR_LEFT        0x04
#define DIR_RIGHT       0x08
#define CELL_SOLVED     0x80
#define CELL_TRACED     0x40
int solve(int x, int y, unsigned char dirEntry)
{
    unsigned char dirOptions;
    /*
     * Keep looking for a solution until exit or dead-end is found
     */
    while (!(x == BORDER_RIGHT-1 && y == Exit))
    {
        if (maze[y][x] & dirEntry)
        {
            txt80();
            printf("Cell inconsistency at %d, %d\n", x, y);
            exit(-1);
        }
        /*
         * Check if this cell already solved
         */
        if (maze[y][x] & CELL_SOLVED)
            return TRUE;
        /*
         * Check if this cell already traced (avoid infinite recursion)
         */
        if (maze[y][x] & CELL_TRACED)
            return FALSE;
        maze[y][x] |= CELL_TRACED;
        /*
         * Get move direction options - not walls or entry direction
         */
        dirOptions = ~(maze[y][x] | dirEntry) & 0x0F;
        /*
         * Check for dead-end
         */
        if (!dirOptions)
        {
            xDeadEnd = x;
            yDeadEnd = y;
            return FALSE;
        }
        /*
         * Look for a single direction to move
         */
        if (dirOptions == DIR_UP)
        {
            y--;
            dirEntry = DIR_DOWN;
        }
        else if (dirOptions == DIR_DOWN)
        {
            y++;
            dirEntry = DIR_UP;
        }
        else if (dirOptions == DIR_LEFT)
        {
            x--;
            dirEntry = DIR_RIGHT;
        }
        else if (dirOptions == DIR_RIGHT)
        {
            x++;
            dirEntry = DIR_LEFT;
        }
        else
        {
            /*
             * Intersection of multiple routes
             */
            unsigned char dir;

            for (dir = 0x08; dir; dir >>= 1)
            {
                if (dir & dirOptions)
                {
                    if (dir == DIR_UP)
                    {
                        if (solve(x, y - 1, DIR_DOWN))
                        {
                            maze[y][x] |= CELL_SOLVED;
                            //return TRUE;
                        }
                    }
                    else if (dir == DIR_DOWN)
                    {
                        if (solve(x, y + 1, DIR_UP))
                        {
                            maze[y][x] |= CELL_SOLVED;
                            //return TRUE;
                        }
                    }
                    else if (dir == DIR_LEFT)
                    {
                        if (solve(x - 1, y, DIR_RIGHT))
                        {
                            maze[y][x] |= CELL_SOLVED;
                            //return TRUE;
                        }
                    }
                    else if (dir == DIR_RIGHT)
                    {
                        if (solve(x + 1, y, DIR_LEFT))
                        {
                            maze[y][x] |= CELL_SOLVED;
                            //return TRUE;
                        }
                    }
                }
            }
            return maze[y][x] & CELL_SOLVED ? TRUE : FALSE;
        }
    }
    maze[y][x] |= CELL_SOLVED;
    return WHITE;
}
void cleartrace(void)
{
    int i, j;

    for (i = BORDER_LEFT; i < BORDER_RIGHT; i++)
        for (j = BORDER_TOP; j < BORDER_BOTTOM; j++)
            maze[j][i] &= ~CELL_TRACED;
}
void buildmaze(void)
{
    int i, j;
    unsigned char wall, solved;

    for (j = 0; j < 100; j += 5)
        hlin(0, 159, j, 15);
    hlin(0, 159, 99, 15);
    for (i = 0; i < 160; i += 8)
        vlin(i, 0, 99, 15);
    vlin(159, 0, 99, 15);
    for (i = BORDER_LEFT; i < BORDER_RIGHT; i++)
        for (j = BORDER_TOP; j < BORDER_BOTTOM; j++)
            maze[j][i] = WALL_TOP | WALL_BOTTOM | WALL_LEFT | WALL_RIGHT;
    /*
     * Pick entrance at left border
     */
    Enter = rand() % BORDER_BOTTOM;
    vlin(0, Enter * 5 + 1, Enter * 5 + 4, 0);
    /*
     * Pick exit at right border
     */
    Exit = rand() % BORDER_BOTTOM;
    vlin(159, Exit * 5 + 1, Exit * 5 + 4, 0);
    /*
     * Make initial pass erasing boxed-in cells
     */
    for (i = BORDER_LEFT; i < BORDER_RIGHT; i++)
    {
        for (j = BORDER_TOP; j < BORDER_BOTTOM; j++)
        {
            while (maze[j][i] == (WALL_TOP | WALL_BOTTOM | WALL_LEFT | WALL_RIGHT))
            {
                /*
                 * Open up a random wall
                 */
                wall = 1 << (rand() & 3);
                if ((i == BORDER_LEFT     && wall == WALL_LEFT)
                 || (i == BORDER_RIGHT-1  && wall == WALL_RIGHT)
                 || (j == BORDER_TOP      && wall == WALL_TOP)
                 || (j == BORDER_BOTTOM-1 && wall == WALL_BOTTOM))
                    /*
                     * Check border walls
                     */
                    continue;
                /*
                 * Erase wall
                 */
                if (wall == WALL_TOP)
                {
                    hlin(i * 8 + 1, i * 8 + 7, j * 5, 0);
                    maze[j - 1][i] ^= WALL_BOTTOM;
                }
                else if (wall == WALL_BOTTOM)
                {
                    hlin(i * 8 + 1, i * 8 + 7, (j + 1) * 5, 0);
                    maze[j + 1][i] ^= WALL_TOP;
                }
                else if (wall == WALL_LEFT)
                {
                    vlin(i * 8, j * 5 + 1, j * 5 + 4, 0);
                    maze[j][i - 1] ^= WALL_RIGHT;
                }
                else if (wall == WALL_RIGHT)
                {
                    vlin((i + 1) * 8, j * 5 + 1, j * 5 + 4, 0);
                    maze[j][i + 1] ^= WALL_LEFT;
                }
                maze[j][i] ^= wall;
            }
        }
    }
    /*
     * Check every cell for a solution
     */
    do
    {
        solved = TRUE;
        for (i = BORDER_LEFT; i < BORDER_RIGHT; i++)
        {
            for (j = BORDER_TOP; j < BORDER_BOTTOM; j++)
            {
                cleartrace();
                if (solve(i, j, DIR_ANY))
                    maze[j][i] |= CELL_SOLVED;
                else
                {
                    /*
                     * Erase a wall at last dead-end
                     */
                    solved = FALSE;
                    for (wall = 0x08; wall; wall >>= 1)
                    {
                        if ((xDeadEnd == BORDER_LEFT     && wall == WALL_LEFT)
                         || (xDeadEnd == BORDER_RIGHT-1  && wall == WALL_RIGHT)
                         || (yDeadEnd == BORDER_TOP      && wall == WALL_TOP)
                         || (yDeadEnd == BORDER_BOTTOM-1 && wall == WALL_BOTTOM))
                            /*
                             * Check border walls
                             */
                            continue;
                        if (maze[yDeadEnd][xDeadEnd] & wall)
                        {
                            /*
                             * Erase wall
                             */
                            if (wall == WALL_TOP)
                            {
                                if (maze[yDeadEnd - 1][xDeadEnd] & CELL_TRACED)
                                    continue;
                                maze[yDeadEnd - 1][xDeadEnd] ^= WALL_BOTTOM;
                                hlin(xDeadEnd * 8 + 1, xDeadEnd * 8 + 7, yDeadEnd * 5, 0);
                            }
                            else if (wall == WALL_BOTTOM)
                            {
                                if (maze[yDeadEnd + 1][xDeadEnd] & CELL_TRACED)
                                    continue;
                                maze[yDeadEnd + 1][xDeadEnd] ^= WALL_TOP;
                                hlin(xDeadEnd * 8 + 1, xDeadEnd * 8 + 7, (yDeadEnd + 1) * 5, 0);
                            }
                            else if (wall == WALL_LEFT)
                            {
                                if (maze[yDeadEnd][xDeadEnd - 1] & CELL_TRACED)
                                    continue;
                                maze[yDeadEnd][xDeadEnd - 1] ^= WALL_RIGHT;
                                vlin(xDeadEnd * 8, yDeadEnd * 5 + 1, yDeadEnd * 5 + 4, 0);
                            }
                            else if (wall == WALL_RIGHT)
                            {
                                if (maze[yDeadEnd][xDeadEnd + 1] & CELL_TRACED)
                                    continue;
                                maze[yDeadEnd][xDeadEnd + 1] ^= WALL_LEFT;
                                vlin((xDeadEnd + 1) * 8, yDeadEnd * 5 + 1, yDeadEnd * 5 + 4, 0);
                            }
                            maze[yDeadEnd][xDeadEnd] ^= wall;
                            break;
                        }
                    }
                }
            }
        }
    } while (!solved);
}
/*
 * Demo tiling and scrolling screen
 */
int main(int argc, char **argv)
{
    unsigned int faceS, viewS, faceT, viewT;
    int incS, incT;
    unsigned long st;
    int movedir, scrolldir;
    unsigned char cycle;
    unsigned char *facebuf;
    unsigned char *scrnbuf;
    struct dostime_t time;

    _dos_gettime(&time);
    srand((time.hsecond << 8) | time.second);
    gr160(0);
    buildmaze();
#if 0
    buildmap();
    facebuf = (unsigned char *)malloc(FACEBUF_HEIGHT*FACEBUF_WIDTH/2);
    /*
     * Set initial coordinates and scroll direction.
     * Horizontal scroll increment must be two,
     * vertical scroll increment can be two or one.
     */
    incS    = 2;
    incT    = 2;
    faceS   = 0x40;
    faceT   = 0xA0;
    viewS   = 0x84 - 80;
    viewT   = 0x84 - 50;
    /*
     * Use hardware scrolling
     */
    tileInit(viewS, viewT, 16, 16, (unsigned char far * far *)tilemap);
    spriteEnable(0, faceS, faceT, FACE_WIDTH, FACE_HEIGHT, face);
    spriteEnable(1,0x94, 0x74, FACE_WIDTH, FACE_HEIGHT, angry);
    viewRefresh(0);
    cycle = 0;
    while (!kbhit())
    {
        frameCount = 0;
        while (frameCount < 60)
        {
            outp(0x3D9, 0x0F);
            /*
             * Update a tile on-the-fly
             */
            tileUpdate(8, 8, tileAnimate[cycle++ & 0x03]);
            /*
             * Change scroll direction at map boundaries
             */
            if ((faceS >= ((16 << 4) - FACE_WIDTH - 2))  || (faceS < 2)) incS = -incS;
            if ((faceT >= ((16 << 4) - FACE_HEIGHT - 2)) || (faceT < 2)) incT = -incT;
            st = spritePosition(0, faceS + incS, faceT + incT);
            faceS = st;
            faceT = st >> 16;
            /*
             * Attempt to keep sprite centered by scrolling map
             */
            scrolldir = 0;
            if (faceS < viewS + (80 - FACE_WIDTH/2))
                scrolldir = SCROLL_RIGHT2;
            else if (faceS > viewS + (80 - FACE_WIDTH/2))
                scrolldir = SCROLL_LEFT2;
            if (faceT < viewT + (50 - FACE_HEIGHT/2))
                scrolldir |= SCROLL_DOWN2;
            else if (faceT > viewT + (50 - FACE_HEIGHT/2))
                scrolldir |= SCROLL_UP2;
            outp(0x3D9, 0x06);
            st = viewRefresh(scrolldir);
            viewS  = st;
            viewT  = st >> 16;
            outp(0x3D9, 0x06);
            //if (getch() == 'Q') {txt80(); tileExit(); return 0;}
        }
    }
    tileExit();
#endif
    getch();
    txt80();
    return 0;
}
